import {decorate, observable, observe} from "mobx"import dbLoader from "../../utils/dbLoader"import {kingdoms} from "./kingdoms"import {BuildingList} from "./buildings/buildings"class Accumulator {	economy = 0	stability = 0	loyalty = 0	defense = 0	unrest = 0	fame = 0}function reducer(b, acc) {	acc.economy += b.economy	acc.stability += b.stability	acc.loyalty += b.loyalty	acc.defense += b.defense	acc.unrest += b.unrest	acc.fame += b.fame}class BuildingDetails {	id = 0	building = null	x = 0	y = 0	constructor(obj) {		this.id = obj.id		this.building = BuildingList.getById(obj.building)		this.x = obj.x		this.y = obj.y	}	toFormData = () => {		const formData = new FormData()		formData.append("id", this.id.toString())		formData.append("building", this.building.id.toString())		formData.append("xcoord", this.x.toString())		formData.append("ycoord", this.y.toString())		return formData	}}class BuildingGrid {	buildings = []	district = null	constructor(obj, district) {		if (obj != null)			obj.forEach((b) => {				this.buildings.push(new BuildingDetails(b))			})		this.district = district	}	addBuilding = (x, y, building) => {		const newBuilding = new BuildingDetails({building: building, x: x, y: y})		this.buildings.push(newBuilding)		return dbLoader("district/buildings", "PUT", newBuilding.toFormData())	}	getBuildingGridModifiers = (accumulator) => {		return this.buildings.reduce(reducer, accumulator)	}}class District {	id = 0	settlement = null	buildingGrid = null	constructor(obj, settlement) {		this.settlement = settlement		if (obj == null) {			this.buildingGrid = new BuildingGrid(null, this)		} else {			this.id = obj.id			this.buildingGrid = new BuildingGrid(obj.buildings, this)		}	}	saveDistrict = () => {		// TODO terribly broken		return dbLoader(`district/${this.id}`, "POST", this.toFormData())	}	toFormData = () => {		const formData = new FormData()		formData.append("settlement", this.settlement.id.toString())		return formData	}	getDistrictModifiers(accumulator) {		if (this.buildingGrid != null)			return this.buildingGrid.getBuildingGridModifiers(accumulator)		return accumulator	}}class Settlement {	id = 0	hex = 0	districts = []	name = "Unnamed settlement"	deleted=false	constructor(obj, hex) {		this.hex = hex		if (obj != null) {			this.id = obj.id			this.name = obj.name			if (obj.districts != null)				obj.districts.forEach((d) => {					this.districts.push(new District(d, this))				})		}	}	saveSettlement = () => {		return dbLoader(`settlement/${this.id}`, "POST", this.toFormData())	}	addDistrict = () => {		const newDistrict = new District(null, this)		this.districts.push(newDistrict)		dbLoader("district", "PUT", newDistrict.toFormData())			.then((out) => {				newDistrict.id = out.id			})	}	toFormData = () => {		const formData = new FormData()		formData.append("name", this.name)		formData.append("hex", this.hex.id.toString())		return formData	}	deleteDistrict = async (id) => {		const index=this.getDistrictIndexById(id)		console.log(`Deleting ${id} at ${index}`)		if(index<0) return		this.districts.splice(index, 1)		await dbLoader(`district/${id}`, "DELETE", null)		this.deleted=true	}	getDistrictIndexById = (id) => {		return this.districts.findIndex((value)=>value.id===id)	}	getDistrictByID = (id) => {		const index=this.getDistrictByID(id)		if(index>0)			return this.districts[index]		return null	}	getSettlementModifiers = (acc) => {		return this.districts.reduce((acc, d) => {			return d.getDistrictModifiers(acc)		}, acc)	}}decorate(Settlement, {	districts:observable})class HexData {	id = 0	x = 0	y = 0	ownedBy = null	terrainType = 0	settlement = null	constructor(obj) {		this.id = obj.id		this.x = obj.x		this.y = obj.y		this.terrainType = obj.terrainType		this.settlement = ((obj.settlement && Object.keys(obj.settlement).length > 0) ? (new Settlement(obj.settlement, this)) : null)		const setOwnedBy = observe(kingdoms, "finishedLoading", change => {			if (change.newValue) {				this.ownedBy = kingdoms.getById(obj.ownedBy)				setOwnedBy()			}		})	}	saveToDb = () => {		dbLoader(`hex/${this.x}-${this.y}`, "POST", this.toFormData())			.then((response) => {				this.id = response[0][0]			})	}	createSettlement = () => {		if (this.settlement == null) {			this.settlement = new Settlement(null, this)			dbLoader("settlement", "PUT", this.settlement.toFormData())				.then((out)=>this.settlement.id=out.id)		}	}	toFormData = () => {		const formData = new FormData()		formData.append("xcoord", this.x.toString())		formData.append("ycoord", this.y.toString())		formData.append("owned_by", (this.ownedBy != null && this.ownedBy.id != null) ? this.ownedBy.id.toString() : 0)		formData.append("terrain_type", this.terrainType.toString())		return formData	}	getSettlementModifiers = (acc) => {		if (this.settlement != null)			return this.settlement.getSettlementModifiers(acc)		return acc	}}class HexDataGrid {	hexGrid = observable([])	loaded = false	selected = -1	initialize = () => {		this.loaded = false		dbLoader("hex/hexData", "GET")			.then((hexes) => {					hexes.forEach((hex) => {						this.hexGrid.push(new HexData(hex))					})					this.loaded = true				}			)	}	getById = (id) => {		this.hexGrid.forEach((hex) => {			if (hex.id === id)				return hex		})		return null	}	getByCoords = (x, y) => {		for (let i = 0; i < this.hexGrid.length; i++)			if (this.hexGrid[i].x === x && this.hexGrid[i].y === y) {				return this.hexGrid[i]			}		return new HexData({id: 0, x: x, y: y, ownedBy: -1, terrainType: -1})	}	getByKingdom = (id) => {		const out = []		for (let i = 0; i < this.hexGrid.length; i++)			if (this.hexGrid[i].ownedBy != null && this.hexGrid[i].ownedBy.id === id)				out.push(this.hexGrid[i])		return out	}	getModifiersByKingdomId = (id) => {		if (id <= 0) return new Accumulator()		const acc = new Accumulator()		this.getByKingdom(id).forEach((value => {			value.getSettlementModifiers(acc)		}))		return acc	}}decorate(HexData, {	ownedBy: observable})decorate(HexDataGrid, {	loaded: observable,	selected: observable})const hexDataGrid = new HexDataGrid()hexDataGrid.initialize()export {HexData, hexDataGrid, Accumulator}